<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Episodes on Go on the toilet</title>
    <link>https://jbszczepaniak.github.io/gott/episodes/</link>
    <description>Recent content in Episodes on Go on the toilet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jbszczepaniak.github.io/gott/episodes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>#13 - About functions implementing interfaces</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode13/</link>
      <pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode13/</guid>
      <description>get pdf here ðŸ–¨ It is commonly known that struct types can implement interfaces, but did you know that any type can implement an interface?
An interface used when working with HTTP servers is Handler. It has one method ServeHTTP and every struct implementing this interface can be registered as a handler for incoming HTTP requests. This is simple implementation of Handler interface.
type helloServer struct{} func (s helloServer) ServeHTTP(w http.</description>
    </item>
    
    <item>
      <title>#12 - Select is not only SQL thing</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode12/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode12/</guid>
      <description>get pdf here ðŸ–¨ The select statement in go gives the ability to listen on many channels at the same time. Let&amp;rsquo;s have a look.
func main() { ch := make(chan int) ch2 := make(chan int) go func() { ch &amp;lt;- 1 }() // sending on separate goroutine to avoid deadlock  select { case v := &amp;lt;-ch: fmt.Printf(&amp;#34;received %d on channel 1&amp;#34;, v) case v := &amp;lt;-ch2: fmt.Printf(&amp;#34;received %d on channel 2&amp;#34;, v) } } This piece of code executes only the first case statement because only the first channel has something that can be received.</description>
    </item>
    
    <item>
      <title>#11 - Concurrency is not parallelism</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode11/</link>
      <pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode11/</guid>
      <description>get pdf here ðŸ–¨ Left side â‘  I hope you&amp;rsquo;ve started reading right here. This is the beginning of this episode. Let&amp;rsquo;s get started with acknowledgment that both parallelism and concurrency deal with the same domain of doing many things &amp;ldquo;at the same time&amp;rdquo;. â†’â‘¡
â‘¢ This is concurrent work in action. You are reading two things at the same time, but you can be focused only on one of them at the time.</description>
    </item>
    
    <item>
      <title>#10 - Do not communicate by sharing memory; instead, share memory by communicating</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode10/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode10/</guid>
      <description>get pdf here ðŸ–¨ This is one of golang&amp;rsquo;s proverbs. Impact of this sentence is bigger than you might think. What does it even mean? It has a meaning only in a concurrent program where separate goroutines want to share information between each other.
Communication by sharing memory means that many goroutines share access to a data structure (which needs a lock protection). This isn&amp;rsquo;t so bad, right? We are used to it, we do this kind of sharing all the time.</description>
    </item>
    
    <item>
      <title>#09 - Golang wants you to be safe</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode09/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode09/</guid>
      <description>get pdf here ðŸ–¨ One of the most powerful features of go is it&amp;rsquo;s concurrency model built around goroutines and channels. Goroutine is a lightweight thread managed by the Go runtime. Channel enables unidirectional communication between goroutines. If you want to know more about channels and goroutines, stay tuned - in upcoming episodes we will take a closer look at them.
One of the problems with concurrent programming is a data race.</description>
    </item>
    
    <item>
      <title>#08 - Do you remember January 2nd, 2006?</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode08/</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode08/</guid>
      <description>get pdf here ðŸ–¨ I don&amp;rsquo;t, but golang certainly cares about it. Let&amp;rsquo;s say you want to convert a string to Time struct. You want to figure out how, you open your terminal and type $ go doc time parse, and this is what you get:
func Parse(layout, value string) (Time, error) Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be Mon Jan 2 15:04:05 -0700 MST 2006 would be interpreted if it were the value; .</description>
    </item>
    
    <item>
      <title>#07 - Let&#39;s talk about the mascot of go</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode07/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode07/</guid>
      <description> get pdf here ðŸ–¨ </description>
    </item>
    
    <item>
      <title>#06 - Functions are first-class citizens.</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode06/</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode06/</guid>
      <description>get pdf here ðŸ–¨ This property has some interesting consequences (we will show 4 of them). Thanks to it you can accept function as an argument to the function and return a function from a function. Because of this we can implement the decorator pattern. Here is one that logs the fact that function started and finished.
func logged(f func(int) int) func(int) int { return func(i int) int { fmt.</description>
    </item>
    
    <item>
      <title>#05 - Are there interfaces in go?</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode05/</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode05/</guid>
      <description>get pdf here ðŸ–¨ Sure, letâ€™s look at one:
type Writer interface { Write(p []byte) (n int, err error) } This is Writer type from standard library (from io package). If you want to implement such interface, you need to have struct with function Write defined on this struct.
Letâ€™s write some dummy implementation of this interface.
type DummyWriter struct {} func (dw DummyWriter) Write (p []byte) (int, error) { return 0, nil } Here we have completely valid and extremely useless Writer implementation.</description>
    </item>
    
    <item>
      <title>#02 - There is no finally. In go you defer stuff.</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode02/</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode02/</guid>
      <description>get pdf here ðŸ–¨ If you want to make sure that something will happen, in go you can use defer. Statement marked with defer will be called at the end of enclosing function.
Examples from Docker project:
defer os.RemoveAll(tmp) // inside test as clean-up step  defer ls.mountL.Unlock() // make sure to release acquired lock  defer f.Close() // close file after reading content  defer body.Close() // close HTTP response body after reading content  defer d.</description>
    </item>
    
    <item>
      <title>#03 - You donâ€™t raise or throw exceptions, you return errors</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode03/</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode03/</guid>
      <description>get pdf here ðŸ–¨ There is a lot of code blocks like this in go:
fileInfo, err := os.Stat(filename) if err != nil { return fmt.Errorf(&amp;#34;could not stat file, err: %v&amp;#34;, err) } Each time you encounter a possibility of error you handle it immediately. You return it and let caller deal with it or you just log it and move on.
In golang errors are normal variables, â€‹error â€‹type is an interface with single method â€‹Error()â€‹.</description>
    </item>
    
    <item>
      <title>#04 - Go is kind of object-oriented.</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode04/</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode04/</guid>
      <description>get pdf here ðŸ–¨ type HealthCheck struct { Interval time.Duration Healthy bool } func (hc HealthCheck) isHealthy() bool { return hc.Healthy } Above you have what you could call a class. It is a struct though with function defined on it.
check := HealthCheck{ Interval: 2*time.Second, Healthy: true, } check2 := &amp;amp;HealthCheck{1*time.Second, true} Look-n-feel of the struct with function defined on it is class-like. You use it as object just like in other languages.</description>
    </item>
    
    <item>
      <title>#01 - Go gives you static types without bureaucracy!</title>
      <link>https://jbszczepaniak.github.io/gott/episodes/episode01/</link>
      <pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jbszczepaniak.github.io/gott/episodes/episode01/</guid>
      <description>get pdf here ðŸ–¨ package main func main() { var i int = 1 // you can declare a variable with type  var j = 2 // but you donâ€™t have to, compiler will know  var x, y, z = &amp;#34;three&amp;#34;, &amp;#34;at&amp;#34;, &amp;#34;once&amp;#34; // you can initialize many variables at a time  // Most probably you will not frequently use var keyword.  simplestInt := 3 simplestString := &amp;#34;hey!</description>
    </item>
    
  </channel>
</rss>